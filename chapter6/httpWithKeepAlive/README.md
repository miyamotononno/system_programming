# 速度改善(1): HTTP/1.1のKeep-Aliveに対応させる

ソケット周りはボトルネックになりやすく、パフォーマンスの問題がユーザーの体感に直結する。例えば、通信が切れる、タイムアウトなどのエラーが発生する可能性も多々ある。最大の効率を得るにはボトルネックを中心に最適化を行うしかない。

そこで、**Keep-Alive**を導入する。HTTP/1.0では、1セットの通信が終わるたびにTCPのコネクションが切れる仕様になっていた。しかし、HTTP/1.1から導入されたKeep-Aliveを使うことで、しばらくの間はTCP接続のコネクションを維持して使い回せる。TCPでは、コネクションの確立及び切断にそれぞれ1.5RTT(ラウンドトリップタイム: 1往復の通信で1RTT)の時間がかかる。一度の送信につき、3RTTのオーバーヘッドがかかってしまう。Keep-Aliveはこのオーバーヘッドを防げるため、速度低下を防ぐことができる。

### Keep-Alive対応のHTTTPサーバー
以下気をつけること:

- Accept()を受信した後にforループがあり、これによりTCPのコネクションが張られた後に何度でもリクエストを受けられる。
- タイムアウト設定も重要である。通信がしばらくないとタイムアウトのエラーでRead()の呼び出しを終了する。設定しなければ相手からレスポンスがあるまでずっとブロックし続けてしまう。
- http.Responseの初期化の際に、HTTPのバージョンを1.1にすること及び及び送信するデータのバイト長が書き込まれている。Go言語のResponse.Write()はHTTP/1.1より古いバージョンが使われる場合もしくは長さがわからない場合は、Connection: closeヘッダーを付与してしまう。

### Keep-Alive対応のHTTPクライアント

サーバー同様、一致度通信を開始したソケットはなるべく再利用する。サーバー側と異なるのは、通信の起点はソケットなので、セッションが切れた場合の再接続はクライアント側にあるという点。切れた場合は、net.Conn型の変数を一度クリアして再試行すること。