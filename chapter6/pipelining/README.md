# 速度改善(4): パイプライニング

### HTTP/1.1におけるパイプライニング

パイプライニングとは、**送受信を非同期化することでトータルの通信にかかる時間を大幅に減らす方法のこと**を指す。レスポンスが来る前に次から次にリクエストを多重で飛ばすことで、最終的に通信が完了するまでの時間を短くする。

しかし、パイプラインはサーバー側できちんとした対応がなされていないと、ブラウザ側のリクエストを正しく処理できないということになり実装にも課題がある。さらに、HTTPパイプラインには、**サーバーはリクエストの順番通りにレスポンスを返さなければならない**という制限がある。仮に、一つ目のリクエスト処理が遅い場合、２個目以降のレスポンスは待ち状態(ヘッドオブラインブロッキング)になり、結果全体の速度が遅くなるといった課題がある。

そのため、パイプライニングは、モダンブラウザはデフォルトでOFFになっており、ほとんど使用されていない。そのためこのディレクトリで実装していない。

### パイプライニングとHTTP/2

パイプライニングでは、1回の送信及び受信内容はHTTP/1.1の通信と全く同じであった。HTTP/2では、ここをバイナリ化して、小さい単位(**フレーム**)に分割する。HTTP/1.1とは異なり、HTTP/2ではヘッダーの圧縮もできるようになった。

HTTPでいうところの一つのリクエストは、HTTP/2では**ストリーム**という単位で扱われる。TCPソケットの視点で見れば、同じストリームID(32bitの数値)を持ったフレームの論理的なグループである。つまり、HTTP/2では1つの接続上にストリームと呼ばれる仮想的な双方向シーケンスを作ること(**ストリームの多重化**)で問題を克服する。

![HTTP/1.1とHTTP/2の比較](https://blog.redbox.ne.jp/images/http2-stream-1024x1015.png)

また、HTTP/2では、パイプライニングで必須だったりリクエストとレスポンスの順序の保証が不要となった。リクエストされていないコンテンツをサーバー側から送ることも可能になった。パイプライニングでは順序を維持する必要があるため、先にリクエストされた巨大なデータが通信された巨大なデータが通信路を占拠してしまうという問題があった。HTTP/2では、いくつかの問題があるが、**サーバー側で優先度を決めてレスポンスの順序も変更できる**ようになっている。


