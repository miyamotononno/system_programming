# UDPとTCPの処理の流れの違い

UDPの通信の流れは以下の図のようになる。

![UDPの通信の流れ](https://ascii.jp/img/2016/12/28/562243/l/023c7e0cbe63b7b5.jpg)

### サーバー側の実装

TCPソケットの場合、接続を受けるサーバーはnet.Listen()関数を呼び、返ってきたnet.Listenerインターフェースでクライアントが接続するのを待っていた。
クライアントが接続してきたら、net.ListenerインターフェースのAccept()メソッドを呼び、お互いに送受信するためのnet.Connインターフェースのオブジェクトを得る。

これに対し、UDPの接続でサーバーが使う関数は**net.ListenPacket()** である。これを呼ぶと、net.Listen()のような「クライアントを待つ」インターフェースではなく、**データ送受信のためのnet.PacketConnというインターフェースが即座に返される。** このnet.PacketConnオブジェクトもio.Readerインターフェースを実装しているため、圧縮やファイル入出力などの高度なAPIと簡単に接続できる。

接続後の処理で注目すべきポイントは**conn.ReadFrom()** である。このメソッドを使うと、通信内容を読み込むと同時に、接続してきた相手のアドレス情報を受け取ることができる。

**net.PacketConnは、サーバー側でクライアントを知らない状態で開かれるソケットであるため、このインターフェースを使ってサーバーから先にメッセージを送ることはできない。** サーバーには、クライアントからリクエストがあった時に、初めてクライアントのアドレスがわかる。通信内容だけを取得し、通信の送信元を識別しないRead()メソッドを使ってしまうと、相手に通信を送り返す必要がある時に対処できなくなってしまう。

ReadFrom()では、TCPのときに紹介した「データの終了を探りながら受信」といった高度な読み込みはできない。そのため、**データサイズが決まらないデータに対しては、フレームサイズ分のバッファや、期待されるデータの最大サイズ分のバッファを作り、そこにデータをまとめて読み込むことになる。** あるいは、バイナリ形式のデータにしてヘッダーにデータ帳などを格納しておき、そこまで先読みしてから必要なバッファを確保して読みこむ、といったコードになる。`server/server.go`では前者の実装になっている。

データの境界まで読み込みが完了し、データが入ったバイト配列(byte[])が手に用意できたら、bytes.Readerやbufio.Readerが使える。また、ReadFrom()で取得したアドレスに対しては、net.PacketConnインターフェースのwriteTo()メソッドを使ってデータを変装することができる。

### クライアント側の実装

クライアントでは相手がわかった上でDial()するので、TCPの場合と同じようにio.Reader, io.Writerインターフェースのまま使うこともできる。しかし、サーバー側でフレームサイズやバイナリ形式に従った読み込みをする関係で、実際にはサーバー側と同じようなコードにすることが多い。

なお、UDPの通信サンプルをネットで調べると、ほとんどのコードではnet.Listen()やnet.Dial()ではなく、net.ListenUDP()やnet.DialUDP()という関数を使っている。結論から言うと、`client/client.go`の例ではどちらを使ってもほぼ変わりない。

しかし、**次節で紹介するUDPのマルチキャストや、前章で見たTCPのKeepAlveなど、プロトコル固有の操作が必要な婆には、それぞれの関数(net.UDPConn, net.TCPConnなど)を明示的に使う必要がある。**

